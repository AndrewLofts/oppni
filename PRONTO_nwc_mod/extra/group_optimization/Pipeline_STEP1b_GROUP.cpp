#include <stdio.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <cstdlib>
using namespace std;

// Updated 2013/07/19
//
// Pipeline_Step1b_GROUP: runs group-level spatial normalization across subjects
// based on anatomical template, for data generated by Pipeline_Step1.
//
// Call as:   
//
// "g++ Pipeline_STEP1.cpp"
//
// "./a.out {subject inputs}.txt {pipelines}.txt {reference T1 anatomical}.nii"
// 
// ** Output results append a "..._sNorm.nii" to the spatially normalized data **

// ------------------------------ functions ------------------------------ //

// FUNCTION: for "target" (dir/niivol.nii), get # volumes
int get_numvols( string file )
{
     int returned, ii, idxX, numvol;
     //
     std::stringstream ss;
     std::string s;
     std::string stringval;
     // 
     ss.str(std::string());
     ss << "nifti_tool -disp_nim -field nt -infiles " << file << " > temp_text.txt";
     s = ss.str();
     returned = system( s.c_str() );
     // ii) 
     ifstream temp ( "temp_text.txt" ); 
     while ( temp.good() )
     {
          // only update if line=good
          s = stringval;
          // query next line
          getline ( temp, stringval );
     }

     ii = 0;
     while( ii != s.npos ) { idxX = ii; ii = s.find(" ", idxX+1); }
     numvol = atoi( string(s, idxX).c_str() );
     
     return( numvol );
}

// ---------------------- main script -------------------------- //

int main(int argc, char* argv[])
{
    // defining key variables -----------------------------------
    int numvol, numsubj, idxX, idxY, returned;
    int ii, jj, kk, mm, nn;
	int idxIN1, idxIN2, idxOUT1, idxOUT2, idxSTRUC1, idxSTRUC2;
    //
    int M_select, C_select, T_select, R_select;
    int iStart, iMiddl, iEnder, pp, scalNum, pptmp;
    int newSTART, newEND;
    //
    string stringoutline, sx;
    string stringval, stringtemp, intextname, inpipelinename, inrefbrickname, inrefanatomic, inprefix;
    string INstr, OUTstr, STRUCstr;
    string OUTstr_sub1, OUTstr_sub2;
    string STRUCstr_sub1, STRUCstr_sub2;
    string brick_indices[100];
    // ----------------------------------------------------------
    
    intextname = argv[1];     // ARG#1: subject input textfile
    inpipelinename = argv[2]; // ARG#2: pipeline list file
    inrefanatomic = argv[3];  // ARG#3: name of T1 anatomical template
    
    // now, open these files 
    idxX     = intextname.find(".txt");
    inprefix = string( intextname, 0, idxX );
    // declare file stream:
    ifstream file_input ( intextname.c_str() ); 
    ifstream file_pplns ( inpipelinename.c_str() ); 
    // declare the anatomical
    string refVolString = string( inrefanatomic );
    
    // test if file_input can be read
    if( file_pplns.is_open() )
    {
        //// ---------------------------- ////
        ////   GET PIPELINE INFORMATION   ////
        //// ---------------------------- ////

         // run though pipeline entries (can be multi-line)
         stringval.clear();
         while ( file_pplns.good() )
         {
              getline ( file_pplns, stringtemp ); // read each line separately
  
              idxX = stringtemp.find_last_of("]");
              stringval += string( stringtemp,0, idxX+1);
              stringval += string(" ");
         }        
         // locate the different pipeline entries in the list
         int idxM1 = stringval.find(   "MOTCOR="); idxM1 += 6;
         int idxC1 = stringval.find(   "CENSOR="); idxC1 += 6;
         int idxR1 = stringval.find("RETROICOR="); idxR1 += 9;
         int idxT1 = stringval.find(  "TIMECOR="); idxT1 += 7;
         int idxS1 = stringval.find(   "SMOOTH="); idxS1 += 6;
         //
         int idxM2 = stringval.find(" ",idxM1+1);
         int idxC2 = stringval.find(" ",idxC1+1);
         int idxR2 = stringval.find(" ",idxR1+1);
         int idxT2 = stringval.find(" ",idxT1+1);         
         int idxS2 = stringval.find(" ",idxS1+1);
         //
         string Mstr = string( stringval, idxM1, idxM2-idxM1 );
         string Cstr = string( stringval, idxC1, idxC2-idxC1 );
         string Rstr = string( stringval, idxR1, idxR2-idxR1 );
         string Tstr = string( stringval, idxT1, idxT2-idxT1 );
         string Sstr = string( stringval, idxS1, idxS2-idxS1 );

         // --|-- choosing which pipelines to run --|-- //
         if     ( Mstr.find("0,1")!=Mstr.npos ){ M_select = 2; }
         else if( Mstr.find("1")  !=Mstr.npos ){ M_select = 1; }
         else if( Mstr.find("0")  !=Mstr.npos ){ M_select = 0; }
         //
         if     ( Cstr.find("0,1")!=Cstr.npos ){ C_select = 2; }
         else if( Cstr.find("1")  !=Cstr.npos ){ C_select = 1; }
         else if( Cstr.find("0")  !=Cstr.npos ){ C_select = 0; } 
         //
         if     ( Rstr.find("0,1")!=Rstr.npos ){ R_select = 2; }
         else if( Rstr.find("1")  !=Rstr.npos ){ R_select = 1; }
         else if( Rstr.find("0")  !=Rstr.npos ){ R_select = 0; } 
         //
         if     ( Tstr.find("0,1")!=Tstr.npos ){ T_select = 2; }
         else if( Tstr.find("1")  !=Tstr.npos ){ T_select = 1; }
         else if( Tstr.find("0")  !=Tstr.npos ){ T_select = 0; } 

         int smo_indices[10];
         // now running through smoothing choices
         iStart=Sstr.find("[");
         iEnder=Sstr.find("]");
         smo_indices[0] = iStart;
         //first comma instance
         pp=Sstr.find(",",iStart+1);
         scalNum=0;
         //
         while( pp!=Sstr.npos )
         {
             scalNum++;
             smo_indices[scalNum] = pp;
             //
             pptmp=Sstr.find(",",pp+1);
             pp=pptmp;
         }
         //
         scalNum++; // this counts total #indices
         smo_indices[scalNum] = iEnder;

         string smoset[scalNum];
         int ii,kk;
         string substr;
         // --> now iterate in list
         for( ii=0; ii<=scalNum-1; ii++ )
         {
             smoset[ii] = string( Sstr, smo_indices[ii]+1,  smo_indices[ii+1] -smo_indices[ii]-1 );
         }

         // end result: vector "smoset" of scalNum total settings
         // count number of pipelines at each stage:
         int nMppl = (1 + int( M_select > 1 )); //
         int nCppl = (1 + int( C_select > 1 )) * nMppl; //
         int nRppl = (1 + int( R_select > 1 )) * nCppl; //
         int nTppl = (1 + int( T_select > 1 )) * nRppl; //
         int nSppl = scalNum*nTppl; //

        if( file_input.is_open()   ) // start reading in lines of input data
        {         
            //
            numsubj  = 0;
            
            while ( file_input.good() ) // parse textfile lines while something can be found
            {
                //// -------------------------------- ////
                ////   READING SUBJECTS INFORMATION   ////
                //// -------------------------------- ////
                
                 getline ( file_input, stringoutline ); // read each line separately
                 // parse input information:
                 idxIN1    = stringoutline.find("IN=");   
                 idxOUT1   = stringoutline.find("OUT="); 
                 idxSTRUC1 = stringoutline.find("STRUCT=");   
                 
                 if ( (idxOUT1!=stringoutline.npos) & (idxIN1!=stringoutline.npos) & (idxSTRUC1!=stringoutline.npos) )
                 {
                     numsubj++;
                     // 
                     // now increment to give starting index
                     idxIN1   += 3;
                     idxOUT1  += 4;
                     idxSTRUC1+= 7; // for group norming
                     // index whitespace immediately following substring
                     idxIN2   = stringoutline.find(" ",idxIN1  +1);
                     idxOUT2  = stringoutline.find(" ",idxOUT1 +1);
                     idxSTRUC2= stringoutline.find(" ",idxSTRUC1 +1);  // for group norming
                     // 
                     INstr    = string( stringoutline, idxIN1,   idxIN2  -idxIN1 );
                     OUTstr   = string( stringoutline, idxOUT1,  idxOUT2-idxOUT1 );
                     STRUCstr = string( stringoutline, idxSTRUC1,idxSTRUC2-idxSTRUC1 );  // for group norming
                     // splitting
                     idxX        = OUTstr.find_last_of("/");
                     OUTstr_sub1 = string( OUTstr, 0, idxX );
                     OUTstr_sub2 = string( OUTstr,  idxX+1 );
                     // splitting -- for group norming
                     idxX          = STRUCstr.find_last_of("/");
                     idxY          = STRUCstr.find_last_of(".");
                     STRUCstr_sub1 = string( STRUCstr,      0, idxX );
                     STRUCstr_sub2 = string( STRUCstr, idxX+1, idxY-idxX-1 );
                     // define string entities in the scope of this subject
                     std::stringstream ss;
                     std::string s;

                     // paths to data
                     ss.str(std::string());
                     ss <<OUTstr_sub1<<"/masks/"<<OUTstr_sub2<<"_mask.nii";
                     string maskpath_m1 = ss.str();
                                                      
// ------------------ MOTION CORRECTION + CENSORING ------------------  //
                     
                     string pplList1[nCppl]; // init first list                     
                     // 
                     kk=0;
                     if( (M_select==0) | (M_select==2) )
                     {
                         if( (C_select==0) | (C_select==2) )
                         {   
                             ss.str(std::string());                             
                             ss << OUTstr <<"_m0c0";
                             pplList1[kk] = ss.str();
                             kk++;
                         }
                         if(  (C_select==1) | (C_select==2) )
                         {
                             ss.str(std::string());                             
                             ss << OUTstr <<"_m0c1";
                             pplList1[kk] = ss.str();
                             kk++;                             
                         }
                     }
                     // 
                     if( (M_select==1) | (M_select==2) )
                     {
                         if( (C_select==0) | (C_select==2) )
                         {   
                             ss.str(std::string());                             
                             ss << OUTstr <<"_m1c0";
                             pplList1[kk] = ss.str();
                             kk++;
                         }
                         if(  (C_select==1) | (C_select==2) )
                         {
                             ss.str(std::string());                             
                             ss << OUTstr <<"_m1c1";
                             pplList1[kk] = ss.str();
                             kk++;                             
                         }
                     }
                                          
// ------------------ RETROICOR ------------------  //
                     
                     string pplList2[nRppl]; // init first list                     
                     // 
                     kk=0;
                     if( (R_select==0) | (R_select==2) )
                     {
                         for(nn=0;nn<nCppl;nn++)
                         {
                             ss.str(std::string());                             
                             ss << pplList1[nn]<<"p0";
                             pplList2[kk] = ss.str();
                             kk++;                             
                         }
                     }
                     // 
                     if( (R_select==1) | (R_select==2) )
                     {
                         for(nn=0;nn<nCppl;nn++)
                         {
                             ss.str(std::string());                             
                             ss << pplList1[nn]<<"p1";
                             pplList2[kk] = ss.str();
                             kk++;          
                         }
                     }
                     
// ------------------ SLICE TIME CORRECTION------------------  //
                     
                     string pplList3[nTppl]; // init first list                     
                     // 
                     kk=0;
                     if( (T_select==0) | (T_select==2) )
                     {
                         for(nn=0;nn<nRppl;nn++)
                         {
                             ss.str(std::string());                             
                             ss << pplList2[nn]<<"t0";
                             pplList3[kk] = ss.str();
                             kk++;
                         }
                     }
                     // 
                     if( (T_select==1) | (T_select==2) )
                     {
                         for(nn=0;nn<nRppl;nn++)
                         {
                             ss.str(std::string());                             
                             ss << pplList2[nn]<<"t1";
                             pplList3[kk] = ss.str();
                             kk++;
                         }
                     }
                     
// ------------------ SPATIAL SMOOTHING ------------------  //
                     
                     string pplList4[nSppl]; // init first list
                     //
                     kk=0;
                     // now to smooth - at each scale, record filename to array + run script //
                     for( nn=0; nn<scalNum; nn++ )
                     {
                        for(mm=0;mm<nTppl;mm++)
                        {
                             ss.str(std::string());
                             ss << pplList3[mm]<<"s"<<smoset[nn];
                             pplList4[kk] = ss.str();
                             kk++;
                        }
                     }

// ------------------ DONE COMPILING BASIC PROCESSING STEPS ------------------ //

// ----------------------- GROUP NORMALIZATION BEGINS -----------------------  //
                     
                     // get the "baseproc" volume as 4D fMRI reference
                     ss.str(std::string());
                     ss <<OUTstr<<"_baseproc";
                     string epiVoluString = ss.str();
                     string epiMaskString = maskpath_m1;
                     
                     // construct spatial normalization direcory
                     ss.str(std::string());
                     ss << "mkdir " <<OUTstr_sub1<<"/spat_norm";
                     s = ss.str();
                     returned = system( s.c_str() );

                     // begin by specifying some base parameters (e.g. voxel dimensions / identity transform)
                     // do only once, assuming that all subjects have same voxel dimensions, FOV etc.
                     //
                     if( numsubj == 1 )
                     {
                         cout << "running spatial-norm preparatory steps" << endl;
                                    
                         // output text file with acquisition parameters
                         ss.str(std::string());
                         ss << "fslhd " << epiVoluString << ".nii > niidims.txt"; 
                         s = ss.str();
                         returned = system( s.c_str() );
                         
                         // initialize voxel dimension parameters
                         string dim1,dim2,dim3,dim4;
                         string pixdim1,pixdim2,pixdim3,pixdim4;
                         // open textfile
                         ifstream temp ( "niidims.txt" ); 
                         //
                         int kline    = 0;
                         int skipnext = 0;
                         // 
                         while ( temp.good() ) // run through the file
                         {

                             getline ( temp, sx );
                             int idx, idxSP;
                             kline++;
                              
                             if( skipnext==0 ) // find lines with "dim<k>" --> #of voxels per dimension
                             {
                                 idx = sx.find("dim1");   
                                 if( idx!=s.npos ) { idxSP = sx.find_last_of(" "); dim1 = string( sx, idxSP );               }
                                 idx = sx.find("dim2");   
                                 if( idx!=sx.npos ) { idxSP = sx.find_last_of(" "); dim2 = string( sx, idxSP );              }
                                 idx = sx.find("dim3");   
                                 if( idx!=sx.npos ) { idxSP = sx.find_last_of(" "); dim3 = string( sx, idxSP );              }
                                 idx = sx.find("dim4");   
                                 if( idx!=sx.npos ) { idxSP = sx.find_last_of(" "); dim4 = string( sx, idxSP ); skipnext = 1;}
                             }
                             //
                             if( skipnext == 1 ) // find lines with "pixdim<k>" --> voxel widths (mm) / (sec on dim4)
                             {
                                 idx = sx.find("pixdim1");   
                                 if( idx!=sx.npos ) { idxSP = sx.find_last_of(" "); pixdim1 = string( sx, idxSP ); }
                                 idx = sx.find("pixdim2");   
                                 if( idx!=sx.npos ) { idxSP = sx.find_last_of(" "); pixdim2 = string( sx, idxSP ); }
                                 idx = sx.find("pixdim3");   
                                 if( idx!=sx.npos ) { idxSP = sx.find_last_of(" "); pixdim3 = string( sx, idxSP ); }
                                 idx = sx.find("pixdim4");   
                                 if( idx!=sx.npos ) { idxSP = sx.find_last_of(" "); pixdim4 = string( sx, idxSP ); }
                             }
                         }
                         temp.close();
                         
                         // use information from "niidims.txt" to create a blank reference header
                         // this is used as common reference when transforming, so that all transformed volumes have same origin
                         ss.str(std::string());
                         ss << "fslcreatehd " << dim1<<" "<<dim2<<" "<<"35"<< " 1 " <<pixdim1<<" "<<pixdim2<<" "<<pixdim3<<" "<<pixdim4<<" 0 0 0 16 blankvol";
                         string s = ss.str();
                         returned = system( s.c_str() );
                         // make a unit matrix, used to do downsampling without transformation
                         returned = system( "rm eye.mat"  );
                         returned = system( "echo 1 0 0 0 >> eye.mat"  );
                         returned = system( "echo 0 1 0 0 >> eye.mat"  );
                         returned = system( "echo 0 0 1 0 >> eye.mat"  );
                         returned = system( "echo 0 0 0 1 >> eye.mat"  );
                     }

                     cout << "Running normalization for :" << OUTstr_sub2 << "..." << endl;
                     // -------------------------[ brain-masking the T1 volume ]
                     ss.str(std::string());
                     ss << "3dSkullStrip -prefix " << OUTstr_sub1 << "/spat_norm/" << STRUCstr_sub2 << "_strip.nii -input " << STRUCstr;
                     s = ss.str();
                     returned = system( s.c_str() );                 
                     // -------------------------[ build transform --> T1 to Ref]
                     // transformation is 3D affine (translate/rotate/shear/reflect) with sinc interpolation
                     ss.str(std::string());
                     ss << "flirt -in " << OUTstr_sub1 << "/spat_norm/" << STRUCstr_sub2 << "_strip.nii -ref " << refVolString << " -out " << OUTstr_sub1 << "/spat_norm/" << STRUCstr_sub2 << "_T1toREF.nii -omat " << OUTstr_sub1 << "/spat_norm/Transmat_T1toREF_" << STRUCstr_sub2 << ".mat -bins 256 -cost corratio -searchrx -90 90 -searchry -90 90 -searchrz -90 90 -dof 12  -interp sinc -sincwidth 7 -sincwindow hanning";
                     s = ss.str();
                     returned = system( s.c_str() );             
                     // -------------------------[ build transform --> EPI to T1]
                     // transformation is of EPI mask to masked T1 volume, using rigidbody+scaling (dof 7) transform
                     ss.str(std::string());
                     ss << "flirt -in " << epiMaskString << " -ref " << OUTstr_sub1 << "/spat_norm/" << STRUCstr_sub2 << "_strip.nii -omat " << OUTstr_sub1 << "/spat_norm/Transmat_EPItoT1_" << OUTstr_sub2 << ".mat -bins 256 -cost corratio -searchrx -90 90 -searchry -90 90 -searchrz -90 90 -dof 7  -interp sinc -sincwidth 7 -sincwindow hanning";
                     s = ss.str();
                     returned = system( s.c_str() );             
                     // -------------------------[ net matrix --> EPI to Ref ]
                     // concatenates (EPI to T1)x(T1 to Ref) matrices
                     ss.str(std::string());
                     ss << "convert_xfm -omat " << OUTstr_sub1 << "/spat_norm/Transmat_EPItoREF_" << OUTstr_sub2 << ".mat -concat " << OUTstr_sub1 << "/spat_norm/Transmat_T1toREF_" << STRUCstr_sub2 << ".mat " << OUTstr_sub1 << "/spat_norm/Transmat_EPItoT1_" << OUTstr_sub2 << ".mat";
                     s = ss.str();
                     returned = system( s.c_str() );             
                     // -------------------------[ build downsampled T1 for reference ]
                     ss.str(std::string());
                     ss << "flirt -in " << OUTstr_sub1 << "/spat_norm/" << STRUCstr_sub2 << "_T1toREF.nii -applyxfm -interp sinc -ref blankvol.nii.gz -init eye.mat -out " << OUTstr_sub1 << "/spat_norm/" << STRUCstr_sub2 << "_T1toREF_downsamp.nii";
                     s = ss.str();
                     returned = system( s.c_str() );             
                     // -------------------------[ transform the two proc EPI data types]
                     cout << epiVoluString<< endl;
                     ss.str(std::string());
                     ss<<"applyxfm4D "<<epiVoluString <<".nii " << OUTstr_sub1 << "/spat_norm/" << STRUCstr_sub2 << "_T1toREF_downsamp.nii " << epiVoluString << "_sNorm.nii " << OUTstr_sub1 << "/spat_norm/Transmat_EPItoREF_" << OUTstr_sub2 << ".mat -singlematrix";
                     s = ss.str();
                     returned = system( s.c_str() );   
                     //

                     for(kk=0;kk<nSppl;kk++)
                     {
                         // -------------------------[ transform the two proc EPI data types]
                         cout << pplList4[kk] <<".nii " << endl;
                         ss.str(std::string());
                         ss<<"applyxfm4D "<< pplList4[kk] <<".nii " << OUTstr_sub1 << "/spat_norm/" << STRUCstr_sub2 << "_T1toREF_downsamp.nii " << pplList4[kk] << "_sNorm.nii " << OUTstr_sub1 << "/spat_norm/Transmat_EPItoREF_" << OUTstr_sub2 << ".mat -singlematrix";
                         s = ss.str();
                         returned = system( s.c_str() );   
                         //
                     }
                     
                     // unzip normed volumes //
                     ss.str(std::string()); 
                     ss << "gunzip " << OUTstr_sub1 << "/*.nii.gz";
                     s = ss.str();
                     returned = system( s.c_str() );                        
                     
// ------------------- GROUP NORMALIZATION ENDS -------------------  //
                
                     cout << epiVoluString<< endl;
                     ss.str(std::string());
                     ss<<"3dAutomask -prefix " << OUTstr_sub1 << "/spat_norm/" << OUTstr_sub2 << "_mask_sNorm.nii " << epiVoluString << "_sNorm.nii";
                     s = ss.str();
                     returned = system( s.c_str() );   
                     //
                 }
            }            
        }
        else
        {
            cout << "ERROR: Unable to read/open input subjectlist - terminating early!\n" << endl;            
        }
    }
    else    
    {
        cout << "ERROR: Unable to read/open input pipelines list - terminating early!\n" << endl;
    }
 
	return 0;
}
